---
title: DAG Blockchain之Byteball原理解析（四）
date: 2018-01-26 23:09:55
categories: 谈点区块链
tags:
  - dag
  - blockchain
  - byteball
  - bitcoin
---


## Byteball的网络结构

从节点功能角度来讲，Byteball网络节点可以分为中继节点（Relay）、中枢节点（Hub）、播报节点（Oracle）、见证人节点（Witness）、钱包节点（Wallet）：

- 中继节点（Relay）：负责向与其连接的节点转发单元，存储整个Byteball区块链数据库，但它本身不保存任何私钥，也不发送任何单元；
- 中枢节点（Hub）：负责为连接到它的设备提供端到端的加密消息传输通道，用于比如收发私密资产、多签名交易、聊天信息等，其它功能与中继节点相同，默认的Hub地址为`wss://byteball.org/bb`；
- 播报节点（Oracle）：负责不间断地向Byteball网络播报数据，数据可以是时间、价格、甚至是Bitcoin交易；
- 见证人节点（Witness）：负责不间断地以固定地址发送单元，任何满足该条件的节点都有可能成为见证人；
- 钱包节点（Wallet）：负责与用户交互，收发交易、消息等。

下图给出了Byteball网络结构的示意图：

![Byteball网络结构](http://oc7urqs4c.bkt.clouddn.com/2018-01-25-byteball_network-1.png)

### 轻节点及其验证过程

从是否存储了完整的区块链数据角度来讲，节点也可以分为全节点和轻节点，全节点保存了完整的区块链数据，而轻节点没有。用户在安装钱包时可以选择是使用全节点还是轻节点。轻节点仅存储与其地址相关的那些单元，它需要从全节点上下载所需要的数据，请求条件包括它信任的见证人列表以及它关注的地址。

> **跳跃列表：**假设直接位于主链上的球的MCI为$i$，如果$i\bmod10=0$，则该球具有跳跃列表（`skiplist_balls`），跳跃列表中的值指向之前的球；对于$i$尾数具有的每一个$0$，跳跃列表中都有一个MCI值与之对应；跳跃列表中的MCI值等于在保持尾数$0$个数相同的情况下最接近$i$的MCI，比如$i=3000$时，对应的跳跃列表为$[2990, 2900, 2000]$。
>
> **跳跃距离：**对于跳跃列表中的MCI值，它与当前球的MCI值的差值称为跳跃距离。
>
> **最近的球：**当前节点已知的距离当前时刻最近的球（`last_ball`），每个单元在发送时必须包含其已知的最近的球。

全节点接收到轻节点发送的见证人列表和关注地址，在其存储单元的数据库中搜索与轻节点关注地址相关的单元。同时，对于每一个相关的单元，全节点构造一条证据链，构造方法如下：

1. 沿着主链回溯，当已收集到轻节点给定见证人列表中的绝大部分见证人时停止（**这是寻找见证人的过程**），记录这些主链上的单元，记作单元集合$C$；
2. 选择单元集合$C$中时间最早的单元（也是MCI最小的单元），获取其`last_ball`；
3. 从`last_ball`这个单元开始沿着主链回溯，直至遇见包含`skiplist_balls`的球停止，记录这些主链上的球，记作球集合$B$；
4. 使用`skiplist_balls`继续沿主链回溯，跳转到`skiplist_balls`中跳跃距离最大的球（**这是不断加速跳跃的过程**）；
5. 重复步骤4，当下一次跳跃超过目标单元时，减小跳跃距离（**这是降速跳跃的过程，极限情况下，不使用`skiplist_balls`回溯，只利用父单元进行回溯**），直到目标单元停止。

对于轻节点而言，全节点给出的证据链是可信的，主要有以下两个原因：

1. 证据链开始的那些单元包含了轻节点信任的见证人发出的单元；
2. 证据链中的连接使用的是`parent_units`（寻找见证人过程）、`last_ball`、`skiplist_balls`、`parent_balls`。

因此，通过证据链的方式，轻节点可以判断某个单元是否有效。

### 端到端加密通道

中枢节点Hub用于为不同的用户设备之间提供可靠的端到端加密数据通道，有点类似邮件服务器。Hub为用户设备提供存储转发服务，用户设备可以选择连接到不同的Hub。用户设备使用websocket连接到到Hub，并采用TLS加密。Hub一旦收到发往某个设备地址的消息，它就会立即转发，转发成功后删除消息。

设备地址是用于标识用户设备的，从而接收其它设备发送的消息，类似于邮件地址。设备地址与钱包地址不同，可以在不同的设备上使用相同的钱包地址。每个设备保存一把永久性的私钥，其对应的公钥做Hash后进行BASE32编码得到设备地址。为了和钱包地址区分开来，设备地址在其开始位置添加0作为标识（0本身并不是BASE32字符）。完整的设备地址还要包括Hub名称，比如`DEVICEADDRESS@hubname.com`。当切换到不同的Hub是，`@`之间的地址是保持不变的。

假设发送消息的设备记作`sender`，接收消息的设备记作`receiver`，`receiver`所连接的Hub为`hub`。那么，当`sender`想要与`receiver`进行通信时，它需要进行以下操作：

1. `sender`修改其Hub地址为`hub`，默认情况下所有设备连接的都是`wss://byteball.org/bb`；
2. `sender`与`receiver`进行配对，可以使用扫描二维码、配对字符串、或者使用`byteball://`起始的链接。

所有设备之间的通信均采用了端到端加密（ECDH+AES）和数字签名（ECDSA）。作为通信的唯一中间人，Hub也无法查看或者修改消息内容，为了提高转发的安全性，设备会生成一个临时私钥，并将对应的公钥上传至它连接的Hub上。同时，设备可以定时地更换临时私钥和公钥。

因此，`sender`在向`receiver`发送消息时，它需要完成以下步骤：

1. 与`hub`连接；
2. 从`hub`获取`receiver`的临时公钥；
3. 生成一次性的密钥对；
4. 根据一次性私钥和`receiver`的临时公钥生成ECDH密钥；
5. 使用ECDH密钥对消息进行AES加密；
6. 添加一次性公钥；
7. 使用设备私钥对整个消息进行签名；
8. 将消息发送给`hub`

对于`receiver`，它首先需要验证消息的签名，然后使用`sender`的一次性公钥和本地的临时私钥解密消息，从而获得消息的内容。

基于Hub的设备端到端加密消息通道可以用于设备之间通信，设备之间相互发送的消息不存入Byteball数据库中。用户可以利用该通道来发送加密文本消息、多签名交易、隐私资产（比如blackbytes）等。

